import { Injectable } from '@nestjs/common';
import { Secret } from '@prisma/client';
import { BaseRepository } from './base.repository';
import { PrismaService } from '../prisma/prisma.service';
import { CreateSecretDto, UpdateSecretDto, PaginationDto } from '../common/validators/zod-schemas';
import { PaginatedResponseDto } from '../common/dto/base.dto';

@Injectable()
export class SecretRepository extends BaseRepository<Secret, CreateSecretDto, UpdateSecretDto> {
  constructor(prisma: PrismaService) {
    super(prisma);
  }

  async create(data: CreateSecretDto, userId?: string): Promise<Secret> {
    // Verify user owns the will
    if (userId) {
      const will = await this.prisma.will.findFirst({
        where: { id: data.willId, userId },
      });
      if (!will) {
        throw new Error('Will not found or access denied');
      }
    }

    return this.prisma.secret.create({
      data,
      include: { will: true },
    });
  }

  async findById(id: string, userId?: string): Promise<Secret | null> {
    const where: any = { id };
    
    // If userId provided, ensure user owns the will
    const include: any = { will: true };
    if (userId) {
      include.will = { where: { userId } };
    }

    return this.prisma.secret.findFirst({
      where,
      include,
    });
  }

  async update(id: string, data: UpdateSecretDto, userId?: string): Promise<Secret> {
    // Verify ownership through will
    if (userId) {
      const secret = await this.prisma.secret.findFirst({
        where: { id },
        include: { will: true },
      });
      if (!secret || secret.will.userId !== userId) {
        throw new Error('Secret not found or access denied');
      }
    }

    return this.prisma.secret.update({
      where: { id },
      data,
      include: { will: true },
    });
  }

  async delete(id: string, userId?: string): Promise<void> {
    // Verify ownership through will
    if (userId) {
      const secret = await this.prisma.secret.findFirst({
        where: { id },
        include: { will: true },
      });
      if (!secret || secret.will.userId !== userId) {
        throw new Error('Secret not found or access denied');
      }
    }

    await this.prisma.secret.delete({ where: { id } });
  }

  async findMany(
    pagination: PaginationDto,
    userId?: string,
    filters?: Record<string, any>
  ): Promise<PaginatedResponseDto<Secret>> {
    const query = this.buildPaginationQuery(pagination);
    
    const where: any = { isActive: true };
    if (filters) {
      Object.assign(where, filters);
    }

    // Filter by user ownership through will
    if (userId) {
      where.will = { userId };
    }
    
    query.where = where;
    query.include = { will: true };

    const secrets = await this.prisma.secret.findMany(query);
    return this.buildPaginatedResponse(secrets, pagination);
  }

  async findByWillId(willId: string, userId?: string): Promise<Secret[]> {
    const where: any = { willId, isActive: true };
    
    // Verify user owns the will
    if (userId) {
      const will = await this.prisma.will.findFirst({
        where: { id: willId, userId },
      });
      if (!will) {
        throw new Error('Will not found or access denied');
      }
    }

    return this.prisma.secret.findMany({
      where,
      include: { will: true },
      orderBy: { priority: 'asc' },
    });
  }

  async findByCategory(category: string, userId?: string): Promise<Secret[]> {
    const where: any = { category, isActive: true };
    
    if (userId) {
      where.will = { userId };
    }

    return this.prisma.secret.findMany({
      where,
      include: { will: true },
      orderBy: { priority: 'asc' },
    });
  }

  async searchByTags(tags: string[], userId?: string): Promise<Secret[]> {
    const where: any = {
      tags: { hasSome: tags },
      isActive: true,
    };
    
    if (userId) {
      where.will = { userId };
    }

    return this.prisma.secret.findMany({
      where,
      include: { will: true },
      orderBy: { priority: 'asc' },
    });
  }
}
