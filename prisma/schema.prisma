// Last Words Prisma Schema
// Comprehensive schema for secure digital legacy management
// All sensitive data stored as encrypted blobs, emails as salted HMAC

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Authenticator {
  id                   String  @id @default(cuid())
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
  aaguid               String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Core Last Words Models
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  
  // Encrypted user data (PII stored as encrypted blobs)
  encryptedPersonalData String? // Contains: full name, phone, address, etc.
  emailHmac             String  @unique // Salted HMAC of email for lookups
  masterKeyWrapped      String? // User's master key wrapped with password-derived key
  keyDerivationSalt     String? // Salt for password-based key derivation
  
  // User preferences and settings
  timezone              String  @default("UTC")
  notificationSettings  Json?   // Encrypted notification preferences
  
  // NextAuth relations
  accounts      Account[]
  sessions      Session[]
  authenticators Authenticator[]
  
  // Alive check system
  lastAliveCheck        DateTime?
  aliveCheckStatus      String   @default("ACTIVE") // ACTIVE, PENDING, CONFIRMED, OVERDUE
  legacyReleaseScheduled Boolean @default(false)
  legacyReleaseDate     DateTime?
  
  // Last Words relations
  wills         Will[]
  beneficiaries Beneficiary[]
  trustedContacts TrustedContact[]
  aliveChecks   AliveCheck[]
  auditLogs     AuditLog[]
  emailTracking EmailTracking[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([emailHmac])
}

model Beneficiary {
  id                    String @id @default(cuid())
  userId                String
  
  // Encrypted beneficiary data
  encryptedContactData  String // Contains: name, email, phone, address, relationship
  emailHmac             String // Salted HMAC of beneficiary email
  
  // Access and verification
  accessKeyWrapped      String? // Beneficiary's access key (wrapped)
  verificationMethod    String  @default("email") // email, sms, manual
  isVerified            Boolean @default(false)
  verificationToken     String?
  verificationExpiresAt DateTime?
  
  // Metadata
  priority              Int     @default(1) // 1=primary, 2=secondary, etc.
  isActive              Boolean @default(true)
  
  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  willBeneficiaries     WillBeneficiary[]
  releaseEvents         ReleaseEvent[]
  shamirShares          ShamirShare[]
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([userId])
  @@index([emailHmac])
}

model Will {
  id                    String @id @default(cuid())
  userId                String
  
  // Basic will metadata (encrypted)
  encryptedTitle        String
  encryptedDescription  String?
  
  // Will content (fully encrypted)
  encryptedContent      String // Main will document content
  contentVersion        Int    @default(1)
  
  // Access control
  requiresWebAuthn      Boolean @default(true)
  accessLevel           String  @default("PRIVATE") // PRIVATE, BENEFICIARY_ONLY, PUBLIC
  
  // Release conditions
  releaseConditions     Json // Encrypted conditions for release
  autoReleaseEnabled    Boolean @default(false)
  manualReleaseEnabled  Boolean @default(true)
  
  // Shamir Secret Sharing configuration
  shamirEnabled         Boolean @default(false)
  shamirThreshold       Int?    // Always 2 for our 2-of-3 scheme
  shamirTotalShares     Int?    // Always 3 for our implementation
  shamirReleaseKeyHash  String? // SHA-256 hash for verification
  
  // Status
  status                String  @default("DRAFT") // DRAFT, ACTIVE, RELEASED, REVOKED
  isActive              Boolean @default(true)
  
  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  secrets               Secret[]
  willBeneficiaries     WillBeneficiary[]
  releaseEvents         ReleaseEvent[]
  shamirShares          ShamirShare[]
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  releasedAt            DateTime?
  
  @@index([userId])
  @@index([status])
}

model TrustedContact {
  id                    String @id @default(cuid())
  userId                String
  
  // Contact information (encrypted)
  name                  String
  email                 String
  userEmail             String? // Original user's email for reference
  
  // Status
  isActive              Boolean @default(true)
  
  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([userId])
}

model AliveCheck {
  id                    String @id @default(cuid())
  userId                String
  
  // Check details
  checkType             String // INITIAL, REMINDER, FINAL, ESCALATION
  token                 String @unique
  sentAt                DateTime
  expiresAt             DateTime
  confirmedAt           DateTime?

  // Status
  status                String @default("SENT") // SENT, OPENED, CLICKED, CONFIRMED, EXPIRED

  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId])
  @@index([token])
  @@index([status])
}

model EmailTracking {
  id                    String @id @default(cuid())
  userId                String
  checkId               String?
  
  // Event details
  eventType             String // OPEN, CLICK, BOUNCE, DELIVER, etc.
  timestamp             DateTime
  userAgent             String?
  ipAddress             String?
  metadata              Json?
  
  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime @default(now())
  
  @@index([userId])
  @@index([eventType])
}

model WillBeneficiary {
  id            String @id @default(cuid())
  willId        String
  beneficiaryId String
  
  // Access permissions for this beneficiary to this will
  accessLevel   String @default("READ") // read, write, admin
  canTriggerRelease Boolean @default(false)
  
  will          Will        @relation(fields: [willId], references: [id], onDelete: Cascade)
  beneficiary   Beneficiary @relation(fields: [beneficiaryId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime @default(now())
  
  @@unique([willId, beneficiaryId])
}

model Secret {
  id                    String @id @default(cuid())
  willId                String
  
  // Secret metadata (encrypted)
  encryptedTitle        String
  encryptedDescription  String?
  secretType            String // password, document, note, crypto_key, etc.
  
  // Secret content (fully encrypted)
  encryptedContent      String // The actual secret data
  encryptedMetadata     String? // Additional metadata (file type, size, etc.)
  
  // Access control
  requiresWebAuthn      Boolean @default(true)
  accessLevel           String  @default("PRIVATE")
  
  // Organization
  category              String? // Personal, Financial, Digital, etc.
  tags                  String[] // Searchable tags
  priority              Int     @default(1)
  
  // Status
  isActive              Boolean @default(true)
  
  will                  Will    @relation(fields: [willId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([willId])
  @@index([secretType])
  @@index([category])
}


model ReleaseEvent {
  id                    String @id @default(cuid())
  willId                String?
  beneficiaryId         String?
  
  // Event details
  eventType             String // manual_release, auto_release, alive_check_failed, emergency
  triggerReason         String // Detailed reason for the release
  
  // Event data (encrypted)
  encryptedEventData    String? // Additional event context
  
  // Status and processing
  status                String @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  processedAt           DateTime?
  
  // Verification and approval
  requiresApproval      Boolean @default(false)
  approvedBy            String? // User ID who approved
  approvedAt            DateTime?
  
  // Metadata
  ipAddress             String?
  userAgent             String?
  
  will                  Will?        @relation(fields: [willId], references: [id], onDelete: SetNull)
  beneficiary           Beneficiary? @relation(fields: [beneficiaryId], references: [id], onDelete: SetNull)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([willId])
  @@index([beneficiaryId])
  @@index([eventType])
  @@index([status])
  @@index([createdAt])
}

model ShamirShare {
  id                    String @id @default(cuid())
  willId                String
  beneficiaryId         String
  
  // Share data
  shareIndex            Int     // 1, 2, or 3 for our 2-of-3 scheme
  xCoordinate           Int     // X coordinate in finite field
  encryptedShareData    String  // Encrypted share bytes (32 bytes for Release Key)
  
  // Metadata
  distributionToken     String? @unique // Token for secure email distribution
  isDistributed         Boolean @default(false)
  distributedAt         DateTime?
  isUsed                Boolean @default(false)
  usedAt                DateTime?
  
  // Security
  accessAttempts        Int     @default(0)
  lastAccessAttempt     DateTime?
  
  will                  Will    @relation(fields: [willId], references: [id], onDelete: Cascade)
  beneficiary           Beneficiary @relation(fields: [beneficiaryId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@unique([willId, shareIndex])
  @@unique([willId, beneficiaryId])
  @@index([willId])
  @@index([beneficiaryId])
  @@index([distributionToken])
}

model AuditLog {
  id                    String @id @default(cuid())
  timestamp             DateTime @default(now())
  userId                String?
  sessionId             String?
  
  // Operation details
  operation             String // authentication, cryptography, shamir_secret_sharing, etc.
  resource              String // user_session, crypto_service, will_document, etc.
  action                String // login, encrypt, distribute, access, etc.
  result                String // success, failure, error
  
  // Event context
  details               Json? // Additional event information
  ipAddress             String?
  userAgent             String?
  duration              Int? // Operation duration in milliseconds
  errorCode             String?
  errorMessage          String?
  
  // Chain hashing for integrity
  previousHash          String? // Hash of previous audit entry
  hash                  String // Hash of this entry including previousHash
  
  user                  User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([operation])
  @@index([resource])
  @@index([action])
  @@index([result])
  @@index([timestamp])
  @@index([hash])
}
